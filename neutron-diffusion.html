<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neutron Diffusion From the Ground Up - Mehul Nair</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Libre+Franklin:wght@300;400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --paper: #FFFFFF;
            --text: #1a1a1a;
            --accent: #E63946;
            --muted: #6B7280;
            --border: #D1D5DB;
            --highlight: rgba(230, 57, 70, 0.08);
            --neutron: #457B9D;
            --nucleus: #E63946;
            --energy: #F4A261;
        }

        ::selection {
            background: rgba(230, 57, 70, 0.2);
            color: var(--text);
        }

        body {
            font-family: 'EB Garamond', serif;
            background: var(--paper);
            color: var(--text);
            line-height: 1.8;
            font-size: 18px;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            opacity: 0.015;
            pointer-events: none;
            z-index: 1;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 80px 60px;
            position: relative;
            z-index: 2;
        }

        nav {
            position: fixed;
            top: 40px;
            right: 60px;
            z-index: 100;
            font-family: 'Libre Franklin', sans-serif;
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 0.3px;
        }

        nav a {
            color: var(--text);
            text-decoration: none;
            margin-left: 30px;
            position: relative;
            transition: color 0.2s ease;
            font-weight: 400;
        }

        nav a::before {
            content: '▸';
            position: absolute;
            left: -12px;
            opacity: 0;
            transition: all 0.2s ease;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--accent);
            margin: 0;
        }

        nav a:hover {
            color: var(--accent);
        }

        nav a:hover::before {
            opacity: 1;
            left: -15px;
        }

        .essay-title {
            font-family: 'Libre Franklin', sans-serif;
            font-size: 48px;
            font-weight: 300;
            letter-spacing: -1px;
            margin-bottom: 10px;
            line-height: 1.15;
            color: var(--text);
        }

        .essay-meta {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 50px;
        }

        .essay-content {
            font-size: 20px;
            line-height: 1.85;
        }

        .essay-content p {
            margin-bottom: 1.5em;
        }

        .foreword {
            font-style: italic;
            color: var(--muted);
            border-left: 2px solid var(--border);
            padding-left: 20px;
            margin-bottom: 2.5em;
        }

        h2 {
            font-family: 'Libre Franklin', sans-serif;
            font-size: 32px;
            font-weight: 400;
            margin-top: 3em;
            margin-bottom: 1em;
            color: var(--text);
            letter-spacing: -0.5px;
        }

        h3 {
            font-family: 'Libre Franklin', sans-serif;
            font-size: 22px;
            font-weight: 500;
            margin-top: 2em;
            margin-bottom: 0.8em;
            color: var(--text);
        }

        .interaction-list {
            margin: 1.5em 0;
            padding-left: 1.5em;
        }

        .interaction-list li {
            margin-bottom: 1em;
            position: relative;
        }

        .interaction-list li::marker {
            color: var(--accent);
        }

        .interaction-type {
            font-weight: 600;
            color: var(--accent);
        }

        .sub-list {
            margin-top: 0.5em;
            padding-left: 1.5em;
            list-style-type: lower-alpha;
        }

        .sub-list li {
            margin-bottom: 0.5em;
        }

        .footnote {
            font-size: 14px;
            color: var(--muted);
            margin-top: 2em;
            padding-top: 1em;
            border-top: 1px solid var(--border);
        }

        .footnote sup {
            color: var(--accent);
            font-weight: 500;
        }

        /* Interactive Elements */
        .interactive-box {
            background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 30px;
            margin: 2em 0;
            position: relative;
            overflow: hidden;
        }

        .interactive-box::before {
            content: 'INTERACTIVE';
            position: absolute;
            top: 12px;
            right: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            color: var(--accent);
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .interactive-title {
            font-family: 'Libre Franklin', sans-serif;
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--muted);
            margin-bottom: 15px;
        }

        /* Neutron Simulation Canvas */
        .simulation-canvas {
            width: 100%;
            height: 300px;
            background: #1a1a2e;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .simulation-canvas canvas {
            width: 100%;
            height: 100%;
        }

        .simulation-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .sim-btn {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: white;
            color: var(--text);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sim-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .sim-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--muted);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Cross Section Visualization */
        .cross-section-demo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 60px;
            padding: 30px 0;
            flex-wrap: wrap;
        }

        .atom-display {
            text-align: center;
        }

        .atom-visual {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            position: relative;
            transition: all 0.3s ease;
        }

        .atom-visual.iron {
            background: radial-gradient(circle, #a8a8a8 0%, #6b6b6b 100%);
            box-shadow: 0 4px 20px rgba(107, 107, 107, 0.3);
        }

        .atom-visual.boron {
            background: radial-gradient(circle, #90c695 0%, #5a8f5e 100%);
            box-shadow: 0 4px 20px rgba(90, 143, 94, 0.3);
        }

        .neutron-view {
            position: absolute;
            border: 3px dashed var(--accent);
            border-radius: 50%;
            opacity: 0;
            transition: all 0.5s ease;
            pointer-events: none;
        }

        .atom-visual.iron .neutron-view {
            width: 60px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .atom-visual.boron .neutron-view {
            width: 200px;
            height: 200px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .show-neutron-view .neutron-view {
            opacity: 1;
        }

        .atom-label {
            font-family: 'Libre Franklin', sans-serif;
            font-weight: 500;
            font-size: 16px;
        }

        .atom-info {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--muted);
            margin-top: 5px;
        }

        .cross-section-slider {
            width: 100%;
            margin-top: 20px;
        }

        .slider-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: var(--border);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Equation Box */
        .equation-box {
            background: var(--highlight);
            border-left: 3px solid var(--accent);
            padding: 20px 25px;
            margin: 2em 0;
            border-radius: 0 6px 6px 0;
        }

        .equation-box .katex {
            font-size: 1.3em;
        }

        .equation-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        /* Diffusion Box Visualization */
        .diffusion-box-container {
            position: relative;
            width: 100%;
            height: 350px;
            margin: 20px 0;
        }

        .diffusion-box-canvas {
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            border-radius: 6px;
        }

        .box-stats-external {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            flex-wrap: wrap;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 13px;
        }

        .stat-item-external {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #f5f5f5;
            border-radius: 20px;
        }

        .stat-item-external.net-change {
            background: var(--highlight);
            border: 1px solid var(--accent);
        }

        .stat-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Clickable Footnotes */
        .footnote-ref {
            color: var(--accent);
            font-size: 0.75em;
            cursor: pointer;
            font-weight: 600;
            vertical-align: super;
            position: relative;
            padding: 0 2px;
            transition: all 0.2s ease;
        }

        .footnote-ref:hover {
            background: var(--highlight);
            border-radius: 2px;
        }

        .footnote-link {
            color: var(--accent);
            border-bottom: 1px dotted var(--accent);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .footnote-link:hover {
            background: var(--highlight);
        }

        .footnote-popup {
            position: absolute;
            bottom: calc(100% + 10px);
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 14px 18px;
            font-size: 13px;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--text);
            width: 360px;
            max-width: 90vw;
            max-height: 200px;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            line-height: 1.6;
        }

        .footnote-popup::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid var(--border);
        }

        .footnote-popup::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid white;
        }

        .footnote-popup.active {
            display: block;
            animation: fadeInUp 0.2s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(5px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .footnote-popup .close-btn {
            position: absolute;
            top: 6px;
            right: 8px;
            font-size: 16px;
            color: var(--muted);
            cursor: pointer;
            line-height: 1;
        }

        .footnote-popup .close-btn:hover {
            color: var(--accent);
        }

        .section-footnotes {
            margin-top: 2em;
            padding-top: 1em;
            border-top: 1px solid var(--border);
        }

        .section-footnotes h4 {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--muted);
            margin-bottom: 10px;
        }

        .section-footnote-item {
            font-size: 14px;
            color: var(--muted);
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }

        .section-footnote-item sup {
            position: absolute;
            left: 0;
            color: var(--accent);
            font-weight: 500;
        }

        /* Flux Visualization */
        .flux-demo {
            position: relative;
            height: 200px;
            background: linear-gradient(90deg, #1a1a2e 0%, #2d2d4a 50%, #1a1a2e 100%);
            border-radius: 6px;
            overflow: hidden;
        }

        .flux-particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .flux-region {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 100px;
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 10px;
            color: rgba(255,255,255,0.5);
        }

        .flux-region.left { left: 20%; }
        .flux-region.right { right: 20%; }

        /* Fick's Law Demo - Enhanced Interactive */
        .ficks-demo-container {
            position: relative;
            height: 300px;
            background: #1a1a2e;
            border-radius: 6px;
            overflow: hidden;
        }

        .ficks-canvas {
            width: 100%;
            height: 100%;
        }

        .ficks-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .ficks-slider-group {
            flex: 1;
            min-width: 200px;
        }

        .ficks-slider-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .ficks-equation-live {
            background: white;
            padding: 15px 20px;
            border-radius: 6px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            text-align: center;
            margin-top: 15px;
            border: 1px solid var(--border);
        }

        .ficks-value {
            color: var(--accent);
            font-weight: 600;
        }

        .barrier-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 80%;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }

        .flow-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: var(--accent);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        /* Math inline */
        .math-inline {
            font-family: 'EB Garamond', serif;
            font-style: italic;
        }

        /* Superscript footnotes */
        sup.fn {
            color: var(--accent);
            font-size: 0.7em;
            cursor: help;
        }

        /* Back link */
        .back-link {
            display: inline-block;
            margin-top: 80px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: var(--muted);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: var(--accent);
        }

        /* Tooltip */
        .tooltip {
            position: relative;
            border-bottom: 1px dotted var(--accent);
            cursor: help;
        }

        .tooltip:hover::after {
            content: attr(data-tip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--text);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 13px;
            white-space: nowrap;
            z-index: 100;
            font-family: 'IBM Plex Mono', monospace;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 60px 24px;
            }

            nav {
                position: static;
                margin-bottom: 40px;
                text-align: center;
            }

            nav a {
                margin: 0 15px;
            }

            nav a::before {
                display: none;
            }

            .essay-title {
                font-size: 36px;
            }

            .essay-content {
                font-size: 18px;
            }

            h2 {
                font-size: 26px;
            }

            .cross-section-demo {
                gap: 30px;
            }

            .atom-visual {
                width: 100px;
                height: 100px;
            }

            .ficks-demo {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 40px 16px;
            }

            .essay-title {
                font-size: 28px;
            }

            .interactive-box {
                padding: 20px 15px;
            }

            .simulation-canvas {
                height: 250px;
            }

            .footnote-popup {
                width: 300px;
                font-size: 12px;
                padding: 12px 14px;
            }
        }
    </style>
</head>
<body>
    <nav>
        <a href="index.html">about</a>
        <a href="experiences.html">experiences</a>
        <a href="essays.html">essays</a>
    </nav>

    <div class="container">
        <h1 class="essay-title">Neutron Diffusion From the Ground Up</h1>
        <div class="essay-meta">neutron-diffusion.txt </div>

        <div class="essay-content">
            <p class="foreword">Quick foreword: This is part one of a guide that serves as both a refresher of a class I very much enjoyed taking by Professor Massimiliano Fratoni and as a resource on something that I think is a bit harder to understand from the ground up. Before reading this I assume some knowledge of calculus, linear algebra and differential equations. However, this article could still be a fun read even if you don't know these as I will try to explain everything conceptually as well!</p>

            <h2>Part 1: The Neutron</h2>

            <p>You probably learned in high school chemistry that the atom has three distinct constituents, the positively charged proton, the negatively charged electron and the neutral neutron.</p>

            <p>Almost all the chemistry we learn about in high school and the first year of undergrad involves the electrons. However, the protons and neutrons inside an atom have their own interactions as well. The protons and neutrons of an atom are collectively referred to as the "nucleus" hence the name: "nuclear physics".</p>

            <p>Neutrons, named as such because they are neutral in charge, help hold nuclei together through the <span class="footnote-link" data-fn="1">strong force</span><span class="footnote-ref" data-fn="1"><sup>1</sup><span class="footnote-popup"><span class="close-btn">×</span>Not relevant to this article but a fun reading topic for another time!</span></span>. As they are neutral they don't experience any <span class="footnote-link" data-fn="2">charged particle interactions</span><span class="footnote-ref" data-fn="2"><sup>2</sup><span class="footnote-popup"><span class="close-btn">×</span>Neutrons do have measurable magnetic moments as a result of being uncharged particles but this will not be relevant.</span></span>. This means that a neutron typically only stops or loses energy when it experiences some sort of collision, usually with nuclei.</p>

            <p>For our purposes, you can think of a neutron as a neutrally charged ball that has the following interactions:</p>

            <ol class="interaction-list">
                <li><span class="interaction-type">Reaction:</span> When a Neutron hits a Nucleus it can cause various nuclear reactions which in turn can yield various products:
                    <ul class="sub-list">
                        <li><strong>Multiplication:</strong> A neutron hits a nucleus and releases multiple neutrons from the nucleus</li>
                        <li><strong>Particle Emission:</strong> A neutron hits a nucleus and out comes another type of particle</li>
                        <li><strong>Fission:</strong> A neutron hits a nucleus and the nucleus splits into several nuclei, a few neutrons and releases some energy</li>
                    </ul>
                </li>
                <li><span class="interaction-type">Production:</span> Neutrons can be produced through Nuclear Reactions, Fusion, Fission and Radioactive Decay. The amount of neutrons produced per fission reaction is specific to that reaction and is determined by the constant ν (nu)</li>
                <li><span class="interaction-type">Absorption:</span> Sometimes when a Neutron hits a nucleus, it will "stick" to the nucleus and extra energy is released through a Gamma Ray</li>
                <li><span class="interaction-type">Scattering:</span> The neutron hits a nucleus and bounces off. If it has the same amount of energy, it's called an "elastic" scatter and if it has a different amount, it is called an "inelastic scatter"</li>
            </ol>

            <!-- Interactive Neutron Simulation -->
            <div class="interactive-box">
                <div class="interactive-title">Neutron Interactions Simulation</div>
                <div class="simulation-canvas" id="neutronSim">
                    <canvas id="neutronCanvas"></canvas>
                </div>
                <div class="simulation-controls">
                    <button class="sim-btn active" data-mode="scatter">Scattering</button>
                    <button class="sim-btn" data-mode="absorb">Absorption</button>
                    <button class="sim-btn" data-mode="fission">Fission</button>
                    <button class="sim-btn" data-mode="all">All Interactions</button>
                </div>
                <div class="legend">
                    <div class="legend-item"><div class="legend-dot" style="background: #457B9D;"></div> Neutron</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #E63946;"></div> Nucleus</div>
                    <div class="legend-item"><div class="legend-dot" style="background: #F4A261;"></div> Energy Release</div>
                </div>
                <p style="font-size: 14px; color: var(--muted); margin-top: 15px; font-family: 'IBM Plex Mono', monospace;">Click anywhere to launch neutrons. Watch how they interact with nuclei!</p>
            </div>

            <h3>Cross Sections</h3>

            <p>Imagine you have a heat camera which shows you how hot something is by looking at it. If you looked through the camera at both a car with its engine on and a house, which one would you be able to see better? Even though the house is bigger, the heat generated by the car's engine would make the car appear clearer on a thermal camera. In the same way that looking through a camera changed the apparent size of the objects, neutrons also "see" the world differently.</p>

            <p>In a neutron's case, the question is more of how likely a neutron is to interact with an atom. If we view the neutron as a hard ball and the atoms as other hard balls, we would assume that larger atoms have higher cross sections. However, neutron energy and atomic properties can change how the neutron "sees" an atom. For example, even though Iron (Fe) is significantly larger than Boron (B), Boron's capture cross section is 200 times that of Iron.</p>

            <!-- Cross Section Interactive -->
            <div class="interactive-box">
                <div class="interactive-title">How Neutrons "See" Atoms</div>
                <p style="font-size: 14px; color: var(--muted); margin-bottom: 20px;">Toggle between physical size and neutron cross-section view</p>
                <div class="cross-section-demo" id="crossSectionDemo">
                    <div class="atom-display">
                        <div class="atom-visual iron">
                            <div class="neutron-view"></div>
                            Fe
                        </div>
                        <div class="atom-label">Iron (Fe)</div>
                        <div class="atom-info">Physical: Large</div>
                        <div class="atom-info">Cross-section: ~2.6 barns</div>
                    </div>
                    <div class="atom-display">
                        <div class="atom-visual boron" style="width: 60px; height: 60px; font-size: 14px;">
                            <div class="neutron-view"></div>
                            B
                        </div>
                        <div class="atom-label">Boron (B)</div>
                        <div class="atom-info">Physical: Small</div>
                        <div class="atom-info">Cross-section: ~767 barns</div>
                    </div>
                </div>
                <div class="simulation-controls" style="justify-content: center;">
                    <button class="sim-btn" id="toggleCrossSection">Show Neutron's View</button>
                </div>
                <p style="font-size: 13px; color: var(--muted); margin-top: 15px; text-align: center; font-style: italic;">The dashed circles show how large each atom appears to a neutron. Notice how Boron appears huge even though the physical atom is small!</p>
            </div>

            <p>For the purposes of this article we can interpret the cross section as how likely the neutron is to interact with something. A higher cross section for a specific interaction means that a neutron is more likely to interact with it.</p>

            <div class="section-footnotes">
                <h4>Section Notes</h4>
                <div class="section-footnote-item"><sup>1</sup> Not relevant to this article but a fun reading topic for another time!</div>
                <div class="section-footnote-item"><sup>2</sup> Neutrons do have measurable magnetic moments as a result of being uncharged particles but this will not be relevant.</div>
            </div>

            <h2>Part 2: Equation of Continuity</h2>

            <p>Neutrons can't just appear out of nowhere, they have to appear or disappear from a system through a process. Let's now imagine a box with some nuclear material inside of it. How do we know how many free neutrons (neutrons that are just floating around) are entering or exiting the system?</p>

            <p>Because we know that there has to be a process to add or remove a free neutron from the system, we just need to add up every process that is adding or removing neutrons and sum them up. The only problem is that there are so many different interactions that could create or remove a neutron.</p>

            <p>In order to simplify this problem, we'll just be focusing on the major interactions that a neutron will have in order to keep this manageable and realistic. In this article we're assuming three major neutron interactions:</p>

            <ol class="interaction-list">
                <li><span class="interaction-type">Production:</span> There is some sort of neutron beam, fission, or fusion reaction that is adding neutrons to the box</li>
                <li><span class="interaction-type">Absorption:</span> A neutron gets absorbed by the materials inside the box</li>
                <li><span class="interaction-type">Leakage:</span> A neutron leaves the box</li>
            </ol>

            <p>This means that we can determine the change in neutrons in the box using the following equation, also known as the equation of continuity:</p>

            <div class="equation-box">
                <div class="equation-label">Equation of Continuity</div>
                <div>$$\text{Change in Neutrons} = \text{Production} - \text{Absorption} - \text{Leakage}$$</div>
            </div>

            <!-- Interactive Diffusion Box -->
            <div class="interactive-box">
                <div class="interactive-title">The Neutron Balance Box</div>
                <div class="diffusion-box-container">
                    <canvas class="diffusion-box-canvas" id="diffusionCanvas"></canvas>
                </div>
                <div class="box-stats-external" id="boxStats">
                    <div class="stat-item-external"><div class="stat-dot" style="background: #2ecc71;"></div> <span>Production: <strong id="prodCount">0</strong></span></div>
                    <div class="stat-item-external"><div class="stat-dot" style="background: #e74c3c;"></div> <span>Absorbed: <strong id="absCount">0</strong></span></div>
                    <div class="stat-item-external"><div class="stat-dot" style="background: #9b59b6;"></div> <span>Leaked: <strong id="leakCount">0</strong></span></div>
                    <div class="stat-item-external net-change">Net Change: <strong id="netChange">0</strong></div>
                </div>
                <div class="simulation-controls">
                    <button class="sim-btn" id="addSource">Add Neutron Source</button>
                    <button class="sim-btn" id="addAbsorber">Add Absorber</button>
                    <button class="sim-btn" id="resetBox">Reset</button>
                </div>
            </div>

            <h3>Mathematically Stating the Equation</h3>

            <p>Now that we have an equation for the change of neutrons in a volume we need to figure out how to model each one mathematically.</p>

            <h3>Change In Neutrons</h3>

            <p>The output of our equation, how much the neutron population changes with time, is also the easiest to model. If you remember from calculus, we already have a way to determine the change in a quantity with respect to another quantity: the derivative.</p>

            <p>Therefore, we can write the change in neutrons with respect to time as: $\frac{\partial n}{\partial t}$.<span class="footnote-ref" data-fn="3"><sup>3</sup><span class="footnote-popup"><span class="close-btn">×</span>If you haven't taken multivariable calculus, you may not be familiar with the symbols I have used for the derivative. These are called partial derivatives and as far as this article is concerned, they only mean that you have to take the derivative with respect to t and t only.</span></span> Now if we want to see that across the entire volume of the box, we have to take an integral to sum up each unit area:</p>

            <div class="equation-box">
                $$\int_V \frac{\partial n}{\partial t} \, dV$$
            </div>

            <h3>Production (Source)</h3>

            <p>For the purposes of this article, we're going to be considering all production as coming from a neutron source. This basically just means there is a beam of neutrons that is hitting the box at some constant rate.<span class="footnote-ref" data-fn="4"><sup>4</sup><span class="footnote-popup"><span class="close-btn">×</span>For those of you who are curious about how this would be done in real life, you could use a deuterium beam with a beryllium breakup target to achieve this.</span></span></p>

            <p>This constant rate would be how many neutrons are added every second per centimeter cubed, a quantity which we will call S. Now if we want to determine how many neutrons are added every second to the entire thing, we would have to sum the neutrons in each square centimeter of the box. We can represent this as an integral:</p>

            <div class="equation-box">
                <div class="equation-label">Production</div>
                $$\text{Production} = \int_V S \, dV$$
            </div>

            <h3>Absorption</h3>

            <p>Now it's time to introduce the concept of flux. Flux is a measure of how many neutrons are passing through a space every second. This is important because the more neutrons go through an area, the more interactions they are going to have (including absorption).</p>

            <!-- Flux Visualization -->
            <div class="interactive-box">
                <div class="interactive-title">Visualizing Neutron Flux</div>
                <div class="flux-demo" id="fluxDemo">
                    <canvas id="fluxCanvas" style="width: 100%; height: 100%;"></canvas>
                </div>
                <p style="font-size: 13px; color: var(--muted); margin-top: 15px; text-align: center;">Here's a little graphic to help you visualize flux. More neutrons = higher flux = more interactions</p>
            </div>

            <p>So if we have a certain amount of neutrons going through a region, how do we know how many of those neutrons will actually absorb into the materials inside the box? If you remember, in part one we described cross sections of a material as the likelihood of interaction with that material. Therefore if we just multiply the amount of neutrons with the likelihood that a neutron will interact with a material, we should get the absorption!</p>

            <p>If we define our cross section as $\Sigma_{abs}$ and our flux as $\phi$ then we can get our total absorption per cubic centimeter. However, if we want absorption throughout the box, we will have to take the integral across the volume meaning our absorption looks like:</p>

            <div class="equation-box">
                <div class="equation-label">Absorption</div>
                $$\text{Absorption} = \int_V \Sigma_{abs} \phi \, dV$$
            </div>

            <h3>Leakage</h3>

            <p>Now that we know the general equations for Absorption and Production, we now need to model what happens when a neutron leaves the box. We could try and look at the flux of the neutrons through all of the sides of the box, but flux is a scalar quantity meaning it doesn't account for the direction of the neutrons. In order to account for direction, we instead use current (J) which is the flux in a specific direction. We want to see the current along all the possible directions a neutron could leave the box. Now if we consider a box, the directions which a neutron could leave are all perpendicular to the faces of the box.</p>

            <p>These perpendicular directions can be called "normal" to the box and the current is said to be along the normal vector (n). This time because we are looking at the neutrons leaving through the faces of the box, not the volume, we instead sum across the surface area of the box. Therefore:</p>

            <div class="equation-box">
                <div class="equation-label">Leakage (Surface Integral)</div>
                $$\text{Leakage} = \int_A \vec{J} \cdot \vec{n} \, dA$$
            </div>

            <p>Now even though we have a perfectly adequate expression for leakage, it's not integrated with respect to volume like the rest of our expressions. So we'll have to use some math in order to turn it into a volume integral. Specifically, we can use <span class="footnote-link" data-fn="5">divergence theorem</span><span class="footnote-ref" data-fn="5"><sup>5</sup><span class="footnote-popup"><span class="close-btn">×</span>See: tutorial.math.lamar.edu/classes/calciii/DivergenceTheorem.aspx</span></span> to perform the conversion such that:</p>

            <div class="equation-box">
                <div class="equation-label">Leakage (Volume Integral)</div>
                $$\text{Leakage} = \int_A \vec{J} \cdot \vec{n} \, dA = \int_V \nabla \cdot \vec{J} \, dV$$
            </div>

            <h3>Putting it All Together</h3>

            <p>Previously we stated the equation as</p>

            <p style="text-align: center; font-style: italic; margin: 1em 0;">Change in Neutrons = Production - Absorption - Leakage</p>

            <p>Let's now put together all the terms we've calculated to get a final equation</p>

            <div class="equation-box">
                $$\int_V \frac{\partial n}{\partial t} \, dV = \int_V S \, dV - \int_V \Sigma_{abs} \phi \, dV - \int_V \nabla \cdot \vec{J} \, dV$$
            </div>

            <p>Since we're integrating over the same volume here and none of these terms are actually volume dependent, we can get rid of the integrals to get us:</p>

            <div class="equation-box">
                <div class="equation-label">The Diffusion Equation</div>
                $$\frac{\partial n}{\partial t} = S - \Sigma_{abs} \phi - \nabla \cdot \vec{J}$$
            </div>

            <p>This is the Diffusion Equation and it can tell us a lot about the behavior of neutrons. From here we can develop a lot of Nuclear Reactor Theory!</p>

            <h3>Fick's Law</h3>

            <p>In particle systems, particles in high concentration regions usually move to lower concentration regions. This is called diffusion and understanding it is key to explaining key particle behaviors. Diffusion also applies to neutrons, a region with a high flux means that there are more possible collisions there which redirect neutrons. This naturally means that neutrons will scatter towards regions where there are less regions.</p>

            <!-- Fick's Law Demo - Enhanced -->
            <div class="interactive-box">
                <div class="interactive-title">Fick's Law: Diffusion in Action</div>
                <p style="font-size: 14px; color: var(--muted); margin-bottom: 15px;">Adjust the concentration gradient and diffusion coefficient to see how particles flow. Current always flows from high to low concentration!</p>
                <div class="ficks-demo-container">
                    <canvas class="ficks-canvas" id="ficksCanvas"></canvas>
                    <div class="barrier-indicator"></div>
                    <div class="flow-indicator" id="flowIndicator">→</div>
                </div>
                <div class="ficks-controls">
                    <div class="ficks-slider-group">
                        <div class="ficks-slider-label">
                            <span>Left Side Concentration (φ₁)</span>
                            <span id="leftConcValue">80</span>
                        </div>
                        <input type="range" id="leftConcSlider" min="10" max="100" value="80">
                    </div>
                    <div class="ficks-slider-group">
                        <div class="ficks-slider-label">
                            <span>Right Side Concentration (φ₂)</span>
                            <span id="rightConcValue">20</span>
                        </div>
                        <input type="range" id="rightConcSlider" min="10" max="100" value="20">
                    </div>
                    <div class="ficks-slider-group">
                        <div class="ficks-slider-label">
                            <span>Diffusion Coefficient (D)</span>
                            <span id="diffCoeffValue">1.0</span>
                        </div>
                        <input type="range" id="diffCoeffSlider" min="1" max="30" value="10">
                    </div>
                </div>
                <div class="ficks-equation-live">
                    J = −D∇φ → Current J = <span class="ficks-value" id="currentValue">-6.0</span> (flowing <span id="flowDirection">right →</span>)
                </div>
            </div>

            <p>If you remember, the current describes the amount of neutrons flowing in a specific direction. We know that the current always flows away from the regions with the highest fluxes as there is more scattering there. We can formalize this through Fick's law which is as follows:</p>

            <div class="equation-box">
                <div class="equation-label">Fick's Law</div>
                $$\vec{J} = -D \nabla \phi$$
            </div>

            <p>In this equation, D is the diffusion constant which is a parameter specific to the material inside the box. We need to take the <span class="footnote-link" data-fn="6">gradient</span><span class="footnote-ref" data-fn="6"><sup>6</sup><span class="footnote-popup"><span class="close-btn">×</span>See: betterexplained.com/articles/vector-calculus-understanding-the-gradient/</span></span> (essentially a sum of derivatives in each direction current can flow in) to account for all three dimensions.</p>

            <h3>Steady State</h3>

            <p>Our current equation has two quantities that have to be calculated, $\frac{\partial n}{\partial t}$ and J. We can use Fick's law in order to put the system in terms of only $\phi$. After plugging in Fick's Law we get<span class="footnote-ref" data-fn="7"><sup>7</sup><span class="footnote-popup"><span class="close-btn">×</span>The divergence of a gradient is the Laplacian or the gradient applied to itself.</span></span></p>

            <div class="equation-box">
                $$\frac{\partial n}{\partial t} = S - \Sigma_{abs} \phi + D \nabla^2 \phi$$
            </div>

            <p>Let's say we want to solve for the values of individual terms when there is no net motion of neutrons through the box, that is when change in neutrons is zero. This is also called Steady State.</p>

            <p>In this case we get the Time-Independent Diffusion Equation, which is when the diffusion equation reaches equilibrium and it is written as:</p>

            <div class="equation-box">
                <div class="equation-label">Time-Independent Diffusion Equation</div>
                $$0 = S - \Sigma_{abs} \phi + D \nabla^2 \phi$$
            </div>

            <div class="section-footnotes">
                <h4>Section Notes</h4>
                <div class="section-footnote-item"><sup>3</sup> If you haven't taken multivariable calculus, you may not be familiar with the symbols I have used for the derivative. These are called partial derivatives and as far as this article is concerned, they only mean that you have to take the derivative with respect to t and t only.</div>
                <div class="section-footnote-item"><sup>4</sup> For those of you who are curious about how this would be done in real life, you could use a deuterium beam with a beryllium breakup target to achieve this.</div>
                <div class="section-footnote-item"><sup>5</sup> Divergence Theorem: See tutorial.math.lamar.edu/classes/calciii/DivergenceTheorem.aspx</div>
                <div class="section-footnote-item"><sup>6</sup> Gradient: See betterexplained.com/articles/vector-calculus-understanding-the-gradient/</div>
                <div class="section-footnote-item"><sup>7</sup> The divergence of a gradient is the Laplacian or the gradient applied to itself.</div>
                
            </div>
            
            <div class="section-footnote-item"><sup></sup> AI Usage: Claude was used to help code a lot of the simulations from mockups I made, the content is all mine! </div>
            <a href="essays.html" class="back-link">← back to essays</a>
        </div>
    </div>

    <script>
        // Initialize KaTeX
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });

            // Initialize all simulations
            initNeutronSim();
            initCrossSectionDemo();
            initDiffusionBox();
            initFluxDemo();
            initFicksDemo();
            initFootnotePopups();
        });

        // ============ NEUTRON INTERACTION SIMULATION ============
        function initNeutronSim() {
            const canvas = document.getElementById('neutronCanvas');
            const container = document.getElementById('neutronSim');
            const ctx = canvas.getContext('2d');
            
            let neutrons = [];
            let nuclei = [];
            let particles = []; // for effects
            let fissionFragments = []; // for split nuclei
            let mode = 'scatter';

            // Create spread out nuclei using grid placement
            function createNuclei() {
                nuclei = [];
                const cols = 4;
                const rows = 2;
                const cellW = (canvas.width - 100) / cols;
                const cellH = (canvas.height - 60) / rows;
                
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        nuclei.push({
                            x: 50 + col * cellW + cellW / 2 + (Math.random() - 0.5) * 40,
                            y: 40 + row * cellH + cellH / 2 + (Math.random() - 0.5) * 30,
                            r: 18 + Math.random() * 8,
                            id: row * cols + col,
                            alive: true
                        });
                    }
                }
            }

            function resize() {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                createNuclei(); // Recreate nuclei on resize
            }
            resize();
            window.addEventListener('resize', resize);

            // Mode buttons
            document.querySelectorAll('.sim-btn[data-mode]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.sim-btn[data-mode]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    mode = btn.dataset.mode;
                    // Reset nuclei when changing mode
                    nuclei.forEach(n => n.alive = true);
                    fissionFragments = [];
                });
            });

            // Click to add neutron - launches UPWARD from cursor
            container.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (canvas.height / rect.height);
                
                // Launch upward with slight horizontal spread
                neutrons.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: -3 - Math.random() * 2, // Negative = upward
                    r: 5,
                    life: 600
                });
            });

            function addParticle(x, y, color, count = 5) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x, y,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        r: 2 + Math.random() * 3,
                        color,
                        life: 30 + Math.random() * 30
                    });
                }
            }

            // Create fission fragments (two halves flying apart)
            function createFissionFragments(nucleus) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2;
                const halfR = nucleus.r * 0.7;
                
                fissionFragments.push({
                    x: nucleus.x,
                    y: nucleus.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    r: halfR,
                    life: 120
                });
                fissionFragments.push({
                    x: nucleus.x,
                    y: nucleus.y,
                    vx: -Math.cos(angle) * speed,
                    vy: -Math.sin(angle) * speed,
                    r: halfR,
                    life: 120
                });
            }

            function animate() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw nuclei
                nuclei.forEach(n => {
                    if (!n.alive) return;
                    const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(1, '#E63946');
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                });

                // Draw fission fragments
                fissionFragments = fissionFragments.filter(f => {
                    f.x += f.vx;
                    f.y += f.vy;
                    f.life--;
                    f.r *= 0.995;

                    const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.r);
                    gradient.addColorStop(0, '#ff6b6b');
                    gradient.addColorStop(1, '#E63946');
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = f.life / 120;
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    return f.life > 0;
                });

                // Update and draw neutrons
                neutrons = neutrons.filter(neutron => {
                    neutron.x += neutron.vx;
                    neutron.y += neutron.vy;
                    neutron.life--;

                    // Check collision with nuclei
                    for (let nucleus of nuclei) {
                        if (!nucleus.alive) continue;
                        const dx = neutron.x - nucleus.x;
                        const dy = neutron.y - nucleus.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < neutron.r + nucleus.r) {
                            const interactionType = mode === 'all' ? 
                                ['scatter', 'absorb', 'fission'][Math.floor(Math.random() * 3)] : mode;

                            if (interactionType === 'scatter') {
                                // Elastic scatter
                                const angle = Math.atan2(dy, dx);
                                const speed = Math.sqrt(neutron.vx * neutron.vx + neutron.vy * neutron.vy);
                                neutron.vx = Math.cos(angle) * speed * 1.1;
                                neutron.vy = Math.sin(angle) * speed * 1.1;
                                neutron.x = nucleus.x + Math.cos(angle) * (neutron.r + nucleus.r + 2);
                                neutron.y = nucleus.y + Math.sin(angle) * (neutron.r + nucleus.r + 2);
                            } else if (interactionType === 'absorb') {
                                addParticle(neutron.x, neutron.y, '#F4A261', 8);
                                return false;
                            } else if (interactionType === 'fission') {
                                // Energy release particles
                                addParticle(nucleus.x, nucleus.y, '#F4A261', 20);
                                
                                // Split the nucleus into two halves
                                createFissionFragments(nucleus);
                                nucleus.alive = false;
                                
                                // Create new neutrons from fission
                                for (let i = 0; i < 2 + Math.floor(Math.random() * 2); i++) {
                                    neutrons.push({
                                        x: nucleus.x,
                                        y: nucleus.y,
                                        vx: (Math.random() - 0.5) * 5,
                                        vy: (Math.random() - 0.5) * 5,
                                        r: 5,
                                        life: 400
                                    });
                                }
                                return false;
                            }
                        }
                    }

                    // Bounce off walls
                    if (neutron.x < neutron.r || neutron.x > canvas.width - neutron.r) neutron.vx *= -1;
                    if (neutron.y < neutron.r || neutron.y > canvas.height - neutron.r) neutron.vy *= -1;

                    // Keep in bounds
                    neutron.x = Math.max(neutron.r, Math.min(canvas.width - neutron.r, neutron.x));
                    neutron.y = Math.max(neutron.r, Math.min(canvas.height - neutron.r, neutron.y));

                    // Draw neutron
                    ctx.beginPath();
                    ctx.arc(neutron.x, neutron.y, neutron.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#457B9D';
                    ctx.fill();

                    return neutron.life > 0;
                });

                // Update and draw particles
                particles = particles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                    p.life--;
                    p.r *= 0.97;

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.life / 60;
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    return p.life > 0 && p.r > 0.5;
                });

                requestAnimationFrame(animate);
            }
            animate();
        }

        // ============ CROSS SECTION DEMO ============
        function initCrossSectionDemo() {
            const btn = document.getElementById('toggleCrossSection');
            const demo = document.getElementById('crossSectionDemo');
            let showingNeutronView = false;

            btn.addEventListener('click', () => {
                showingNeutronView = !showingNeutronView;
                demo.classList.toggle('show-neutron-view', showingNeutronView);
                btn.textContent = showingNeutronView ? 'Show Physical Size' : "Show Neutron's View";
                btn.classList.toggle('active', showingNeutronView);
            });
        }

        // ============ DIFFUSION BOX SIMULATION ============
        function initDiffusionBox() {
            const canvas = document.getElementById('diffusionCanvas');
            const ctx = canvas.getContext('2d');
            
            function resize() {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
            }
            resize();
            window.addEventListener('resize', resize);

            let neutrons = [];
            let sources = [];
            let absorbers = [];
            let stats = { produced: 0, absorbed: 0, leaked: 0 };

            const boxPadding = 40;
            const box = {
                x: boxPadding,
                y: boxPadding,
                w: 0,
                h: 0
            };

            function updateBoxSize() {
                box.w = canvas.width - boxPadding * 2;
                box.h = canvas.height - boxPadding * 2;
            }
            updateBoxSize();

            // Add source
            document.getElementById('addSource').addEventListener('click', () => {
                sources.push({
                    x: box.x + 30 + Math.random() * (box.w - 60),
                    y: box.y + 30 + Math.random() * (box.h - 60),
                    timer: 0
                });
            });

            // Add absorber
            document.getElementById('addAbsorber').addEventListener('click', () => {
                absorbers.push({
                    x: box.x + 30 + Math.random() * (box.w - 60),
                    y: box.y + 30 + Math.random() * (box.h - 60),
                    r: 20
                });
            });

            // Reset
            document.getElementById('resetBox').addEventListener('click', () => {
                neutrons = [];
                sources = [];
                absorbers = [];
                stats = { produced: 0, absorbed: 0, leaked: 0 };
                updateStats();
            });

            function updateStats() {
                document.getElementById('prodCount').textContent = stats.produced;
                document.getElementById('absCount').textContent = stats.absorbed;
                document.getElementById('leakCount').textContent = stats.leaked;
                document.getElementById('netChange').textContent = stats.produced - stats.absorbed - stats.leaked;
            }

            function animate() {
                updateBoxSize();
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw box
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(box.x, box.y, box.w, box.h);

                // Labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '12px "IBM Plex Mono", monospace';
                ctx.fillText('LEAKAGE →', canvas.width - 90, box.y + box.h / 2);
                ctx.fillText('← LEAKAGE', 5, box.y + box.h / 2);

                // Draw and update sources
                sources.forEach(s => {
                    ctx.beginPath();
                    ctx.arc(s.x, s.y, 12, 0, Math.PI * 2);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.fillText('+', s.x - 4, s.y + 5);

                    s.timer++;
                    if (s.timer > 30) {
                        s.timer = 0;
                        neutrons.push({
                            x: s.x,
                            y: s.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            r: 4
                        });
                        stats.produced++;
                        updateStats();
                    }
                });

                // Draw absorbers
                absorbers.forEach(a => {
                    ctx.beginPath();
                    ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.6)';
                    ctx.fill();
                    ctx.strokeStyle = '#e74c3c';
                    ctx.stroke();
                });

                // Update neutrons
                neutrons = neutrons.filter(n => {
                    n.x += n.vx;
                    n.y += n.vy;

                    // Check absorption
                    for (let a of absorbers) {
                        const dx = n.x - a.x;
                        const dy = n.y - a.y;
                        if (Math.sqrt(dx * dx + dy * dy) < a.r + n.r) {
                            stats.absorbed++;
                            updateStats();
                            return false;
                        }
                    }

                    // Check leakage
                    if (n.x < box.x || n.x > box.x + box.w || n.y < box.y || n.y > box.y + box.h) {
                        stats.leaked++;
                        updateStats();
                        return false;
                    }

                    // Draw
                    ctx.beginPath();
                    ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
                    ctx.fillStyle = '#457B9D';
                    ctx.fill();

                    return true;
                });

                requestAnimationFrame(animate);
            }
            animate();
        }

        // ============ FLUX DEMO ============
        function initFluxDemo() {
            const canvas = document.getElementById('fluxCanvas');
            const ctx = canvas.getContext('2d');
            
            function resize() {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
            resize();
            window.addEventListener('resize', resize);

            let particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push({
                    x: Math.random() * 800,
                    y: Math.random() * 200,
                    speed: 1 + Math.random() * 2
                });
            }

            function animate() {
                ctx.fillStyle = 'rgba(26, 26, 46, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                particles.forEach(p => {
                    p.x += p.speed;
                    if (p.x > canvas.width) {
                        p.x = 0;
                        p.y = Math.random() * canvas.height;
                    }

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = '#457B9D';
                    ctx.fill();

                    // Trail
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x - 15, p.y);
                    ctx.strokeStyle = 'rgba(69, 123, 157, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                requestAnimationFrame(animate);
            }
            animate();
        }

        // ============ FICK'S LAW DEMO - ENHANCED ============
        function initFicksDemo() {
            const canvas = document.getElementById('ficksCanvas');
            const ctx = canvas.getContext('2d');
            
            const leftSlider = document.getElementById('leftConcSlider');
            const rightSlider = document.getElementById('rightConcSlider');
            const diffSlider = document.getElementById('diffCoeffSlider');
            const leftValue = document.getElementById('leftConcValue');
            const rightValue = document.getElementById('rightConcValue');
            const diffValue = document.getElementById('diffCoeffValue');
            const currentValue = document.getElementById('currentValue');
            const flowDirection = document.getElementById('flowDirection');
            const flowIndicator = document.getElementById('flowIndicator');
            
            function resize() {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
            }
            resize();
            window.addEventListener('resize', resize);

            let particles = [];
            let leftConc = 80;
            let rightConc = 20;
            let diffCoeff = 1.0;

            // Initialize particles
            function initParticles() {
                particles = [];
                const totalLeft = Math.floor(leftConc / 2);
                const totalRight = Math.floor(rightConc / 2);
                
                for (let i = 0; i < totalLeft; i++) {
                    particles.push({
                        x: Math.random() * canvas.width * 0.45 + 20,
                        y: Math.random() * (canvas.height - 40) + 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        side: 'left'
                    });
                }
                for (let i = 0; i < totalRight; i++) {
                    particles.push({
                        x: canvas.width * 0.55 + Math.random() * canvas.width * 0.4,
                        y: Math.random() * (canvas.height - 40) + 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        side: 'right'
                    });
                }
            }
            initParticles();

            function updateValues() {
                leftConc = parseInt(leftSlider.value);
                rightConc = parseInt(rightSlider.value);
                diffCoeff = parseInt(diffSlider.value) / 10;
                
                leftValue.textContent = leftConc;
                rightValue.textContent = rightConc;
                diffValue.textContent = diffCoeff.toFixed(1);
                
                // Calculate current using Fick's law: J = -D * (dφ/dx)
                const gradient = (rightConc - leftConc) / 100; // Simplified gradient
                const current = -diffCoeff * gradient;
                currentValue.textContent = current.toFixed(2);
                
                // Update flow direction indicator
                if (Math.abs(current) < 0.1) {
                    flowDirection.textContent = 'equilibrium ⟷';
                    flowIndicator.textContent = '⟷';
                    flowIndicator.style.color = '#2ecc71';
                } else if (current > 0) {
                    flowDirection.textContent = 'right →';
                    flowIndicator.textContent = '→';
                    flowIndicator.style.color = '#E63946';
                } else {
                    flowDirection.textContent = '← left';
                    flowIndicator.textContent = '←';
                    flowIndicator.style.color = '#E63946';
                }
                
                // Scale flow indicator based on magnitude
                const scale = 1 + Math.abs(current) * 0.3;
                flowIndicator.style.transform = `translate(-50%, -50%) scale(${scale})`;
                
                initParticles();
            }

            leftSlider.addEventListener('input', updateValues);
            rightSlider.addEventListener('input', updateValues);
            diffSlider.addEventListener('input', updateValues);

            function animate() {
                ctx.fillStyle = '#1a1a2e';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw center barrier with gap
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(canvas.width / 2 - 2, 0, 4, canvas.height * 0.35);
                ctx.fillRect(canvas.width / 2 - 2, canvas.height * 0.65, 4, canvas.height * 0.35);
                
                // Draw side labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '12px "IBM Plex Mono", monospace';
                ctx.fillText(`φ₁ = ${leftConc}`, 20, 25);
                ctx.fillText(`φ₂ = ${rightConc}`, canvas.width - 70, 25);
                
                // Background gradients to show concentration
                const leftGrad = ctx.createLinearGradient(0, 0, canvas.width / 2, 0);
                leftGrad.addColorStop(0, `rgba(69, 123, 157, ${leftConc / 200})`);
                leftGrad.addColorStop(1, `rgba(69, 123, 157, ${leftConc / 400})`);
                ctx.fillStyle = leftGrad;
                ctx.fillRect(0, 0, canvas.width / 2, canvas.height);
                
                const rightGrad = ctx.createLinearGradient(canvas.width / 2, 0, canvas.width, 0);
                rightGrad.addColorStop(0, `rgba(69, 123, 157, ${rightConc / 400})`);
                rightGrad.addColorStop(1, `rgba(69, 123, 157, ${rightConc / 200})`);
                ctx.fillStyle = rightGrad;
                ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);

                // Determine flow bias based on concentration difference
                const gradient = (rightConc - leftConc) / 100;
                const flowBias = -diffCoeff * gradient * 0.05;

                particles.forEach(p => {
                    // Add bias towards flow direction
                    p.vx += flowBias * 0.1;
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Add some random motion
                    p.vx += (Math.random() - 0.5) * 0.3;
                    p.vy += (Math.random() - 0.5) * 0.3;
                    
                    // Damping
                    p.vx *= 0.98;
                    p.vy *= 0.98;

                    // Bounce off walls
                    if (p.x < 5) { p.x = 5; p.vx *= -0.8; }
                    if (p.x > canvas.width - 5) { p.x = canvas.width - 5; p.vx *= -0.8; }
                    if (p.y < 5) { p.y = 5; p.vy *= -0.8; }
                    if (p.y > canvas.height - 5) { p.y = canvas.height - 5; p.vy *= -0.8; }

                    // Barrier interaction (with gap in middle)
                    const centerX = canvas.width / 2;
                    const gapTop = canvas.height * 0.35;
                    const gapBottom = canvas.height * 0.65;
                    
                    if (Math.abs(p.x - centerX) < 8) {
                        // Allow through the gap
                        if (p.y > gapTop && p.y < gapBottom) {
                            // Particle can pass through
                        } else {
                            // Bounce off barrier
                            if (p.x < centerX) {
                                p.x = centerX - 8;
                            } else {
                                p.x = centerX + 8;
                            }
                            p.vx *= -0.5;
                        }
                    }

                    // Draw particle
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                });

                requestAnimationFrame(animate);
            }
            animate();
            updateValues();
        }

        // ============ FOOTNOTE POPUPS ============
        function initFootnotePopups() {
            // Handle clicks on footnote reference numbers
            document.querySelectorAll('.footnote-ref').forEach(ref => {
                ref.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Close all other popups
                    document.querySelectorAll('.footnote-popup.active').forEach(p => {
                        if (p !== ref.querySelector('.footnote-popup')) {
                            p.classList.remove('active');
                        }
                    });
                    
                    const popup = ref.querySelector('.footnote-popup');
                    popup.classList.toggle('active');
                });
            });

            // Handle clicks on footnote link text (e.g., "gradient", "strong force")
            document.querySelectorAll('.footnote-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const fnId = link.getAttribute('data-fn');
                    const ref = document.querySelector(`.footnote-ref[data-fn="${fnId}"]`);
                    
                    if (ref) {
                        // Close all other popups
                        document.querySelectorAll('.footnote-popup.active').forEach(p => {
                            p.classList.remove('active');
                        });
                        
                        const popup = ref.querySelector('.footnote-popup');
                        popup.classList.toggle('active');
                    }
                });
            });

            // Close popups when clicking elsewhere
            document.addEventListener('click', () => {
                document.querySelectorAll('.footnote-popup.active').forEach(p => {
                    p.classList.remove('active');
                });
            });

            // Close button functionality
            document.querySelectorAll('.footnote-popup .close-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    btn.parentElement.classList.remove('active');
                });
            });
        }
    </script>
</body>
</html>
